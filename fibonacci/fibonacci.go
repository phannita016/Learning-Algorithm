package main

import "fmt"

/*
	สมมติว่าคุณกำลังจะขึ้นบันไดที่มีจำนวนขั้น n ขั้น คุณสามารถกระโดดขึ้นไปได้ทีละ 1 ขั้น หรือ 2 ขั้นต่อครั้ง คุณต้องการรู้ว่ามีวิธีทั้งหมดกี่วิธีในการขึ้นไปถึงขั้นสูงสุดของบันได

	ข้อกำหนด:
		- คุณสามารถกระโดดขึ้นบันไดทีละ 1 ขั้น หรือ 2 ขั้นเท่านั้น
		- เขียนฟังก์ชัน countWays(n int) int ที่จะคืนค่าจำนวนวิธีทั้งหมดในการขึ้นไปถึงขั้นที่ n

	***การวิเคราะห์ประสิทธิภาพ***
		- การทำงานในเวลา O(n)

	Tabulation: ใช้ iterative approach โดยเก็บผลลัพธ์ทุกค่าในอาร์เรย์ dp และคำนวณไปข้างหน้าเรื่อย ๆ
	ข้อดี:
		- ไม่มี overhead จากการเรียกฟังก์ชัน recursive
		- ประสิทธิภาพการคำนวณดีเพราะใช้การวนลูปที่มีโครงสร้างเรียบง่าย
	ข้อเสีย:
		- ใช้หน่วยความจำมากกว่าเพราะต้องเก็บค่า Fibonacci ทั้งหมดตั้งแต่ 0 ถึง n ในอาร์เรย์
*/

func fibonacci(n int) int {
	// ถ้าค่า n น้อยกว่าหรือเท่ากับ 1 จะคืนค่า n กลับทันที เนื่องจาก fibonacci ลำดับที่ 0=0 , ลำกับที่ 1=1
	if n <= 1 {
		return n
	}

	dp := make([]int, n+1) //สร้างอาร์เรย์ dp ขนาด n+1 เก็บค่าที่คำนวณได้
	dp[0] = 0              //กำหนดค่าเริ่มต้นตามลำดับ fibonacci
	dp[1] = 1              //กำหนดค่าเริ่มต้นตามลำดับ fibonacci

	for i := 2; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2] //สูตร Fibonacci(i) = Fibonacci(i−1) + Fibonacci(i−2)
	}

	return dp[n] //คืนค่า fibonacci ลำดับที่ n
}

func main() {
	n := 10
	result := fibonacci(n)
	fmt.Printf("Number of ways to reach step %d is %d\n", n, result)
}
